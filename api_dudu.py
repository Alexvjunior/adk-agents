import os
import logging
import json
import tempfile
import sqlite3
import csv
from datetime import datetime
from dotenv import load_dotenv
from fastapi import FastAPI, Request, UploadFile, File
from agno.agent import Agent
from agno.models.openai import OpenAIChat
from agno.storage.agent.sqlite import SqliteAgentStorage
from agno.tools.knowledge import KnowledgeTools
from agno.tools.googlecalendar import GoogleCalendarTools
from agno.tools.shell import ShellTools
from agno.document.chunking.recursive import RecursiveChunking
from agno.knowledge.agent import AgentKnowledge
from agno.vectordb.chroma import ChromaDb
from agno.document.reader.text_reader import TextReader
from agno.embedder.openai import OpenAIEmbedder  # Mudan√ßa para OpenAI
from pathlib import Path
from evolution_api_tools import EvolutionApiTools

# Carregar vari√°veis de ambiente
load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()


# Inicializar banco de dados para restaurantes
def init_restaurant_db():
    """Inicializa o banco de dados de restaurantes"""
    conn = sqlite3.connect("restaurantes.db")
    cursor = conn.cursor()
    
    cursor.execute("""
        CREATE TABLE IF NOT EXISTS restaurantes (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            nome TEXT NOT NULL,
            numero TEXT NOT NULL UNIQUE,
            primeira_mensagem_enviada BOOLEAN DEFAULT FALSE,
            data_envio DATETIME,
            created_at DATETIME DEFAULT CURRENT_TIMESTAMP
        )
    """)
    
    conn.commit()
    conn.close()
    logger.info("‚úÖ Banco de dados de restaurantes inicializado")


# Inicializar DB na importa√ß√£o
init_restaurant_db()


# Usar vari√°vel de ambiente para Google API Key
google_api_key = os.getenv("GOOGLE_API_KEY", 
                           "AIzaSyCKTbPQDtAhUI9VWQH26_v2KJW3146Xe20")
os.environ["GOOGLE_API_KEY"] = google_api_key

# Configurar OpenAI API Key
openai_api_key = os.getenv("OPENAI_API_KEY")
if not openai_api_key:
    logger.error("‚ùå OPENAI_API_KEY n√£o configurada!")
else:
    os.environ["OPENAI_API_KEY"] = openai_api_key
    logger.info("‚úÖ OpenAI API Key configurada")

storage = SqliteAgentStorage(table_name="sessions", db_file="sessions.db")

# üöÄ SISTEMA DE CONHECIMENTO OTIMIZADO - Usando embeddings da OpenAI
agent_knowledge = AgentKnowledge(
    vector_db=ChromaDb(
        collection="elo_marketing_knowledge",
        embedder=OpenAIEmbedder(
            id="text-embedding-3-large",  # Modelo mais avan√ßado da OpenAI
            api_key=os.environ.get("OPENAI_API_KEY"),
            dimensions=3072,  # Dimens√µes m√°ximas para melhor precis√£o
        ),
        path="knowledge_db", 
        persistent_client=True,
    ),
    chunking_strategy=RecursiveChunking(
        chunk_size=800,  # Otimizado para o modelo
        overlap=200,     # Maior overlap para melhor contexto
    ),
    num_documents=10,  # Aumentado para mais contexto
)

# Processar documentos do diret√≥rio knowledge/
reader = TextReader(chunk=True)
knowledge_dir = Path("knowledge/")
if knowledge_dir.exists():
    for file_path in knowledge_dir.iterdir():
        if file_path.is_file() and file_path.suffix in ['.txt', '.md']:
            print(f"üìÑ Processando arquivo: {file_path}")
            documents = reader.read(file_path)
            for doc in documents:
                print(f"‚úÖ Documento adicionado: {doc.name}")
                agent_knowledge.add_document_to_knowledge_base(document=doc)
else:
    logger.warning("‚ö†Ô∏è Diret√≥rio 'knowledge/' n√£o encontrado")

# üîß FERRAMENTAS DE CONHECIMENTO - Usando o mesmo sistema
knowledge_tools = KnowledgeTools(
    knowledge=agent_knowledge,  # Usando o mesmo sistema do agente
    think=True,
    search=True,
    analyze=True,
    instructions=(
        "Use sempre as conversas reais para responder perguntas. "
        "Procure por respostas espec√≠ficas no knowledge base antes de "
        "responder. Priorize informa√ß√µes precisas e atualizadas."
    ),
)


def create_google_calendar_tools():
    """Cria GoogleCalendarTools usando vari√°veis de ambiente"""
    try:
        # Criar estrutura de credenciais a partir de vari√°veis de ambiente
        credentials_dict = {
            "installed": {
                "client_id": os.getenv("GOOGLE_CLIENT_ID"),
                "project_id": os.getenv("GOOGLE_PROJECT_ID"),
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
                "auth_provider_x509_cert_url": (
                    "https://www.googleapis.com/oauth2/v1/certs"
                ),
                "client_secret": os.getenv("GOOGLE_CLIENT_SECRET"),
                "redirect_uris": [
                    "http://localhost", 
                    "https://agentes-agents.iaz7eb.easypanel.host/"
                ]
            }
        }
        
        # Criar estrutura de token a partir de vari√°veis de ambiente
        token_dict = {
            "refresh_token": os.getenv("GOOGLE_REFRESH_TOKEN"),
            "token_uri": "https://oauth2.googleapis.com/token",
            "client_id": os.getenv("GOOGLE_CLIENT_ID"),
            "client_secret": os.getenv("GOOGLE_CLIENT_SECRET"),
            "scopes": ["https://www.googleapis.com/auth/calendar"],
            "universe_domain": "googleapis.com"
        }
        
        # Criar arquivos tempor√°rios para as credenciais
        with tempfile.NamedTemporaryFile(
            mode='w', suffix='.json', delete=False
        ) as credentials_file:
            json.dump(credentials_dict, credentials_file)
            credentials_path = credentials_file.name
            
        with tempfile.NamedTemporaryFile(
            mode='w', suffix='.json', delete=False
        ) as token_file:
            json.dump(token_dict, token_file)
            token_path = token_file.name
        
        # Criar e retornar GoogleCalendarTools
        return GoogleCalendarTools(
            credentials_path=credentials_path,
            token_path=token_path,
        )
        
    except Exception as e:
        logger.error(f"Erro ao criar GoogleCalendarTools: {e}")
        # Retorna None se houver erro, para o agente funcionar sem calend√°rio
        return None


# Criar ferramentas de calend√°rio usando vari√°veis de ambiente
calendar = create_google_calendar_tools()

# Ferramenta Shell para executar comandos (obter data/hora atual)
shell_tools = ShellTools(base_dir=Path("."))

# Criar ferramentas Evolution API para WhatsApp
try:
    evolution_tools = EvolutionApiTools(
        server_url='https://evolution-api-evolution-api.iaz7eb.easypanel.host',
        api_key='88B69AFEDA22-4836-858D-72852AA04B1F',
        instance='Dudu Numero N√£o Usando'
    )
    logger.info("Evolution API Tools configurado com sucesso")
except Exception as e:
    logger.error(f"Erro ao configurar Evolution API Tools: {e}")
    evolution_tools = None

# Definir ferramentas baseado na disponibilidade do calend√°rio
tools = [shell_tools, knowledge_tools]
if calendar:
    tools.append(calendar)
    logger.info("Google Calendar configurado com sucesso")
else:
    warning_msg = ("Google Calendar n√£o configurado - "
                   "verifique as vari√°veis de ambiente")
    logger.warning(warning_msg)

# Adicionar Evolution API Tools se dispon√≠vel
if evolution_tools:
    # Configurar ferramentas para execu√ß√£o direta
    evolution_tools.external_execution_required_tools = []
    tools.append(evolution_tools)
    logger.info("Evolution API Tools adicionado ao agente")
    # Debug: Log available methods
    logger.info(f"üîß M√©todos dispon√≠veis nas ferramentas: {dir(evolution_tools)}")
    logger.info(f"üîß Fun√ß√µes das ferramentas: {evolution_tools.functions}")
else:
    logger.error("‚ùå Evolution API Tools n√£o est√° dispon√≠vel")


# Criar agente Vanessa - Vendedora da Elo Marketing
vanessa = Agent(
    name="Vanessa",
    role="Vendedora da Elo Marketing especializada em restaurantes",
    model=OpenAIChat(
        id="gpt-4o",  # Atualizado para GPT-4o (mais avan√ßado)
        temperature=0.7,
        max_tokens=1000,
        top_p=0.9,
        frequency_penalty=0.0,
        presence_penalty=0.0,
    ),
    storage=storage,
    tools=tools,  # Adicionado shell_tools
    knowledge=agent_knowledge,
    add_history_to_messages=True,
    tool_choice="auto",
    instructions=[
        "Voc√™ √© Vanessa, vendedora da Elo Marketing.",
        "",
        "üö® REGRA CR√çTICA - DATA ATUAL:",
        "SEMPRE use shell_tools para consultar a data de hoje ANTES de "
        "agendar!",
        "Comando: ['date', '+%A, %d de %B de %Y']",
        "NUNCA invente datas - SEMPRE consulte o sistema!",
        "",
        "üö® REGRA #1 - AGENDAMENTO (OBRIGAT√ìRIO):",
        "Se cliente disser: 'reuni√£o', 'marcar', 'agendar', 'aceito', 'topa'",
        "IMEDIATAMENTE execute em sequ√™ncia:",
        "1. list_events() - OBRIGAT√ìRIO para ver agenda",
        "2. Sugira 2 hor√°rios livres: 'Eduardo tem ter√ßa 14h e quinta 16h'",
        "3. Quando cliente escolher: create_event() - OBRIGAT√ìRIO",
        "",
        "üö® NUNCA sugira hor√°rios sem executar list_events() primeiro!",
        "üö® NUNCA confirme agendamento sem executar create_event()!",
        "",
        "üÜò N√öMERO DE EMERG√äNCIA:",
        "Se houver qualquer problema na conversa ou n√£o conseguir comunicar:",
        "- Ferramentas n√£o funcionam",
        "- Cliente muito confuso ou irritado", 
        "- Problema t√©cnico no sistema",
        "- N√£o consegue agendar ap√≥s 3 tentativas",
        "Redirecione para: 5548996438314 (WhatsApp de suporte)",
        "Diga: 'Para melhor atendimento, entre em contato: 5548996438314'",
        "",
        "üö® INSTRU√á√ïES CR√çTICAS DE AGENDAMENTO - FLUXO OBRIGAT√ìRIO:",
        "",
        "‚ö° GATILHOS PARA USAR FERRAMENTAS (palavras-chave):",
        "Se cliente disser: 'reuni√£o', 'marcar', 'agendar', 'aceito', "
        "'topa', 'sim, quero'",
        "‚Üí IMEDIATAMENTE execute este fluxo OBRIGAT√ìRIO:",
        "",
        "üî• PASSO 1 - CONSULTAR CALEND√ÅRIO (OBRIGAT√ìRIO):",
        "ANTES de sugerir qualquer hor√°rio, SEMPRE EXECUTE:",
        "list_events() ‚Üê Esta ferramenta √© OBRIGAT√ìRIA!",
        "NUNCA sugira hor√°rios sem consultar a agenda primeiro!",
        "",
        "üìÖ PASSO 1.5 - CONSULTAR DATA ATUAL (OBRIGAT√ìRIO):",
        "ANTES de sugerir datas, SEMPRE EXECUTE:",
        "shell_tools com comando: ['date', '+%A, %d de %B de %Y']",
        "NUNCA invente datas - SEMPRE consulte o sistema!",
        "Certifique-se que datas sugeridas s√£o FUTURAS, n√£o passadas!",
        "",
        "üî• PASSO 2 - SUGERIR HOR√ÅRIOS BASEADOS NA AGENDA REAL:",
        "Ap√≥s executar list_events(), responda EXATAMENTE assim:",
        "'Consultei a agenda do Eduardo. Ele tem disponibilidade ter√ßa √†s "
        "14h ou quarta √†s 10h'",
        "OU: 'Eduardo est√° livre quinta de manh√£ √†s 9h ou sexta √†s 15h'", 
        "OU: 'A agenda mostra vagas segunda √†s 11h ou ter√ßa √†s 16h'",
        "SEMPRE ofere√ßa 2 hor√°rios espec√≠ficos diferentes!",
        "",
        "üî• PASSO 3 - COLETAR DADOS QUANDO CLIENTE ESCOLHER:",
        "Cliente escolhe hor√°rio ‚Üí Responda:",
        "'Para finalizar, preciso: nome completo, nome do restaurante e "
        "email'",
        "COLETE TODOS os dados antes de criar o evento!",
        "",
        "üî• PASSO 4 - CRIAR EVENTO NO CALEND√ÅRIO (OBRIGAT√ìRIO):",
        "Quando tiver todos os dados, SEMPRE EXECUTE:",
        "create_event(timezone='America/Sao_Paulo', "
        "add_google_meet_link=True)",
        "NUNCA confirme agendamento sem executar create_event()!",
        "",
        "üî• PASSO 5 - CONFIRMAR COM LINK DO MEET:",
        "Ap√≥s create_event(), responda:",
        "'Reuni√£o agendada para [data/hora]!'",
        "'Link do Google Meet: [url extra√≠do do evento criado]'",
        "'Eduardo j√° recebeu os detalhes por email'",
        "",
        "‚ùå PROIBI√á√ïES ABSOLUTAS:",
        "- JAMAIS sugira hor√°rios sem executar list_events() primeiro",
        "- JAMAIS confirme agendamento sem executar create_event()",
        "- JAMAIS diga 'Eduardo entrar√° em contato' - VOC√ä agenda!",
        "- JAMAIS pergunte 'qual hor√°rio prefere' sem dar op√ß√µes espec√≠ficas",
        "- JAMAIS finja que agendou sem usar as ferramentas",
        "",
        "‚úÖ EXEMPLO COMPLETO OBRIGAT√ìRIO:",
        "Cliente: 'Aceito agendar'",
        "Voc√™: EXECUTA shell_tools(['date', '+%A, %d de %B de %Y']) para "
        "saber que dia √© hoje",
        "Voc√™: EXECUTA list_events() para ver agenda dispon√≠vel",
        "Voc√™: 'Consultei a agenda do Eduardo. Ele tem disponibilidade "
        "ter√ßa √†s 14h ou quinta √†s 16h'",
        "Cliente: 'Ter√ßa √†s 14h'", 
        "Voc√™: 'Para finalizar, preciso: nome completo, nome do "
        "restaurante e email'",
        "Cliente: 'Jo√£o Silva, Restaurante Sabor, joao@email.com'",
        "Voc√™: EXECUTA create_event() com data FUTURA correta",
        "Voc√™: 'Reuni√£o agendada para ter√ßa √†s 14h! Link do Google Meet: "
        "[url]'",
        "",
        "üö® TIMEZONE OBRIGAT√ìRIO:",
        "SEMPRE use timezone='America/Sao_Paulo' em create_event()",
        "SEMPRE use add_google_meet_link=True em create_event()",
        "",
        "üîÑ GERENCIAMENTO DE AGENDAMENTOS:",
        "",
        "üìÖ CANCELAMENTO DE REUNI√ÉO:",
        "Se cliente disser: 'cancelar', 'desmarcar', 'n√£o posso mais'",
        "1. Use list_events() para encontrar a reuni√£o do cliente",
        "2. Use delete_event() para cancelar a reuni√£o",
        "3. Confirme: 'Reuni√£o cancelada com sucesso!'",
        "",
        "‚úèÔ∏è ALTERA√á√ÉO DE HOR√ÅRIO:",
        "Se cliente disser: 'mudar hor√°rio', 'alterar', 'outro dia'",
        "1. Use list_events() para encontrar a reuni√£o atual",
        "2. Use delete_event() para cancelar a reuni√£o antiga",
        "3. Use list_events() novamente para ver disponibilidade",
        "4. Sugira novos hor√°rios livres",
        "5. Use create_event() para novo hor√°rio escolhido",
        "",
        "üö´ PREVEN√á√ÉO DE CONFLITOS - REGRA ABSOLUTA:",
        "NUNCA agende duas reuni√µes no mesmo hor√°rio!",
        "SEMPRE verifique list_events() antes de create_event()",
        "Se hor√°rio j√° ocupado, sugira alternativas:",
        "'Esse hor√°rio j√° est√° ocupado. Posso ter√ßa √†s 15h ou quinta √†s 14h'",
        "",
        "üîç VERIFICA√á√ÉO OBRIGAT√ìRIA ANTES DE AGENDAR:",
        "1. EXECUTE list_events() primeiro",
        "2. ANALISE os hor√°rios ocupados",
        "3. SUGIRA apenas hor√°rios LIVRES",
        "4. CONFIRME que n√£o h√° conflito antes de create_event()",
        "",
        "PITCH ATACANTE - USE IMEDIATAMENTE QUANDO APROPRIADO:",
        "Eu trabalho ajudando restaurantes a aumentarem suas vendas atrav√©s "
        "do marketing digital. Conseguimos faturar mais de R$ 877.000 para "
        "nossos clientes com investimento de apenas R$ 7 mil. Crescimento "
        "de mais de 300% nas vendas.",
        "",
        "üì¢ ABERTURA PADR√ÉO (j√° foi enviada por outro sistema):",
        "A pergunta 'Oi, √© do Restaurante? Voc√™s t√™m card√°pio ou menu online?' "
        "J√Å FOI ENVIADA por outro sistema.",
        "CONTINUE a conversa a partir da resposta do cliente a essa pergunta.",
        "N√ÉO repita a abertura - v√° direto ao acompanhamento.",
        "",
        "üö® PROIBIDO FINGIR QUE AGENDOU:",
        "JAMAIS diga 'reuni√£o foi agendada' sem executar create_event!",
        "JAMAIS diga 'aguarde contato do Eduardo' - VOC√ä faz o agendamento!",
        "Se cliente pedir reuni√£o: SEMPRE sugira hor√°rios espec√≠ficos primeiro!",
        "",
        "‚úÖ FLUXO CORRETO OBRIGAT√ìRIO:",
        "1. Cliente: 'quero reuni√£o' ‚Üí Voc√™: EXECUTE list_events()",
        "2. Baseado na agenda ‚Üí Sugira: 'Posso hoje √†s 14h ou amanh√£ √†s 10h?'",
        "3. Cliente escolhe ‚Üí EXECUTE create_event() com o hor√°rio escolhido",
        "4. Confirme: 'Agendado! Eduardo te liga [dia] √†s [hora]!'",
        "",
        "üéØ HOR√ÅRIOS PADR√ÉO PARA SUGERIR:",
        "Segunda a Sexta: 9h, 10h, 14h, 15h, 16h",
        "SEMPRE ofere√ßa pelo menos 2 op√ß√µes diferentes",
        "Exemplo: 'Tenho segunda √†s 14h ou ter√ßa √†s 10h. Qual prefere?'",
        "",
        "üöÄ REGRAS DE FECHAMENTO:",
        "1. SEMPRE ofere√ßa 2-3 hor√°rios espec√≠ficos quando h√° interesse",
        "2. Use ferramentas de calend√°rio para agendar NA HORA",
        "3. Confirme dados: nome, telefone, nome do restaurante",
        "4. Finalize com: 'Agendado! Eduardo te liga na data marcada!'",
        "",
        "üì± FERRAMENTAS DE WHATSAPP DISPON√çVEIS:",
        "- Use send_text_message para enviar mensagens de texto via WhatsApp",
        "- Use send_media_message para enviar imagens quando mencionar "
        "resultados",
        "- Use check_whatsapp_number para verificar se um n√∫mero est√° no "
        "WhatsApp",
        "- Formato de n√∫mero: 5548999999999 (c√≥digo pa√≠s + DDD + n√∫mero)",
        "",
        "üî• REGRA FINAL OBRIGAT√ìRIA:",
        "Para CADA resposta que voc√™ gerar, EXECUTE send_text_message!",
        "Nunca apenas retorne texto - SEMPRE envie via send_text_message!",
        "Formato: send_text_message(number='554896438314', "
        "text='sua_resposta_aqui')",
        "",
        "üö® AGENDAMENTO - REGRA ABSOLUTA:",
        "Quando cliente pedir reuni√£o, RESPONDA EXATAMENTE assim:",
        "'√ìtimo! Posso agendar segunda √†s 14h ou ter√ßa √†s 10h. Qual prefere?'",
        "NUNCA diga que 'agendou' sem o cliente escolher hor√°rio primeiro!",
        "NUNCA mencione 'Eduardo entrar√° em contato' - sugira hor√°rios "
        "espec√≠ficos!",
        "",
        "üìù SCRIPT LITERAL - SIGA EXATAMENTE:",
        "Se mensagem cont√©m: 'reuni√£o' ou 'marcar' ou 'agendar'",
        "RESPONDA SEMPRE: 'Perfeito! Que tal amanh√£ √†s 14h ou quinta √†s "
        "16h? Qual hor√°rio fica melhor?'",
        "N√ÉO pe√ßa dados pessoais. N√ÉO diga que precisa confirmar. SUGIRA "
        "HOR√ÅRIOS!"
    ],
    markdown=True,
    show_tool_calls=True,
)


def extract_evolution_data(data):
    """Extrai dados da Evolution API"""
    try:
        # Estrutura t√≠pica da Evolution API
        if isinstance(data, dict):
            # Tentar diferentes estruturas poss√≠veis
            message = None
            audio_base64 = None
            image_base64 = None
            message_type = 'text'  # Padr√£o: texto
            remote_jid = None
            push_name = None
            instance = None

            # NOVO FORMATO 2025: Verificar se √© o novo formato com camada 'data'
            if 'data' in data and isinstance(data['data'], dict):
                payload_data = data['data']
                logger.info("üì¶ Novo formato Evolution API 2025 detectado")
                
                # Extrair mensagem do novo formato
                if ('message' in payload_data and 
                        isinstance(payload_data['message'], dict)):
                    if 'conversation' in payload_data['message']:
                        message = payload_data['message']['conversation']
                        message_type = 'text'
                    elif ('imageMessage' in payload_data['message'] and 
                          'base64' in payload_data['message']):
                        image_base64 = payload_data['message']['base64']
                        message_type = 'image'
                    elif ('audioMessage' in payload_data['message'] and 
                          'base64' in payload_data['message']):
                        audio_base64 = payload_data['message']['base64']
                        message_type = 'audio'
                
                # Extrair informa√ß√µes do remetente do novo formato
                if ('key' in payload_data and 
                        isinstance(payload_data['key'], dict)):
                    remote_jid = payload_data['key'].get('remoteJid', 
                                                         'unknown')
                
                if 'pushName' in payload_data:
                    push_name = payload_data['pushName']
                
                # Instance do payload principal
                if 'instance' in data:
                    instance = data['instance']

            # FORMATO ANTIGO: Verificar se √© o formato com 'query' e 'inputs'
            elif 'query' in data and 'inputs' in data:
                message = data['query']
                message_type = 'text'
                # Extrair informa√ß√µes de inputs
                inputs = data['inputs']
                if isinstance(inputs, dict):
                    remote_jid = inputs.get('remoteJid', 'unknown')
                    push_name = inputs.get('pushName', 'Cliente')
                    instance = inputs.get('instanceName', 'default')
                logger.info("üì¶ Formato antigo Evolution API detectado")

            # Verificar se √© mensagem de imagem (formato antigo)
            elif ('message' in data and isinstance(data['message'], dict) and
                    'imageMessage' in data['message'] and 
                    'base64' in data['message']):
                image_base64 = data['message']['base64']
                message_type = 'image'
                logger.info("üñºÔ∏è Mensagem de imagem detectada")

            # Verificar se √© mensagem de √°udio (formato antigo)
            elif ('message' in data and isinstance(data['message'], dict) and
                    'audioMessage' in data['message'] and 
                    'base64' in data['message']):
                audio_base64 = data['message']['base64']
                message_type = 'audio'
                logger.info("üìª Mensagem de √°udio detectada")

            # Op√ß√£o 1: data.message.conversation (texto) - formato antigo
            elif 'message' in data and isinstance(data['message'], dict):
                if 'conversation' in data['message']:
                    message = data['message']['conversation']
                elif 'text' in data['message']:
                    message = data['message']['text']

            # Op√ß√£o 2: data.text ou data.message direto - formato antigo
            elif 'text' in data:
                message = data['text']
            elif 'message' in data and isinstance(data['message'], str):
                message = data['message']
            elif 'question' in data:  # Para testes diretos
                message = data['question']

            # Extrair informa√ß√µes do remetente (formato antigo)
            if not remote_jid:  # S√≥ se n√£o foi definido no novo formato
                if 'key' in data and isinstance(data['key'], dict):
                    remote_jid = data['key'].get('remoteJid', 'unknown')
                elif 'from' in data:
                    remote_jid = data['from']
                elif 'user' in data:  # Novo formato pode ter 'user'
                    remote_jid = data['user']

            if not push_name:  # S√≥ se n√£o foi definido no novo formato
                if 'pushName' in data:
                    push_name = data['pushName']
                elif 'sender_name' in data:
                    push_name = data['sender_name']

            # Capturar instance ou instanceId
            if not instance:  # S√≥ se n√£o foi definido no novo formato
                if 'instanceId' in data:
                    instance = data['instanceId']
                elif 'instance' in data:
                    instance = data['instance']

            return {
                'message': message,
                'audio_base64': audio_base64,
                'image_base64': image_base64,
                'message_type': message_type,
                'remote_jid': remote_jid or 'unknown',
                'push_name': push_name or 'Cliente',
                'instance': instance or 'default'
            }

    except Exception as e:
        logger.error(f"Erro ao extrair dados da Evolution: {e}")

    return None


@app.get("/")
async def root():
    return {
        "message": "Vanessa - Vendedora Elo Marketing | Especialista em "
                   "Restaurantes",
        "description": (
            "Assistente de vendas especializada em marketing digital para "
            "restaurantes. Ajuda a captar leads qualificados e marcar "
            "reuni√µes com resultados comprovados: crescimento de 300% e "
            "faturamento de R$ 862.000 em um m√™s."
        ),
        "endpoints": {
            "/ask": "Conversa com Vanessa para capta√ß√£o de leads",
            "/status": "Status do sistema de capta√ß√£o"
        },
        "example_curl": (
            "curl -X POST http://127.0.0.1:8080/ask "
            "-H 'Content-Type: application/json' "
            "-d '{\"question\": \"Oi, √© do restaurante?\"}'"
        ),
        "evolution_api": "Compat√≠vel com webhooks da Evolution API",
        "sessions": "Hist√≥rico de conversas por cliente com SQLite",
        "objetivo": "Capta√ß√£o de leads e agendamento de reuni√µes com Eduardo",
        "script_source": "faq.txt - Base de conhecimento vetorizada com Agno",
        "knowledge_system": ("Sistema de conhecimento vetorizado para busca "
                             "sem√¢ntica no script de vendas")
    }


@app.post("/ask")
async def ask_vanessa(request: Request):
    """Conversa com Vanessa - Vendedora da Elo Marketing"""
    try:
        # Log completo do que estamos recebendo
        body = await request.body()
        logger.info("üì• DADOS RAW RECEBIDOS (Evolution API):")
        logger.info(f"   - Body raw: {body}")
        content_type = request.headers.get('content-type')
        logger.info(f"   - Content-Type: {content_type}")

        try:
            data = await request.json()
            logger.info(f"   - JSON parsed: {data}")
        except Exception as json_error:
            logger.error(f"   - Erro ao fazer parse JSON: {json_error}")
            return {
                "error": "Dados recebidos n√£o s√£o JSON v√°lido",
                "raw_data": body.decode()
            }

        # Extrair dados espec√≠ficos da Evolution API
        evolution_data = extract_evolution_data(data)

        if not evolution_data:
            logger.warning("Dados n√£o conseguiram ser extra√≠dos da Evolution")
            return {
                "error": "Dados n√£o conseguiram ser extra√≠dos",
                "received_data": data,
            }

        # Verificar se temos conte√∫do (texto, √°udio ou imagem)
        has_text = evolution_data['message'] is not None
        has_audio = evolution_data['audio_base64'] is not None
        has_image = evolution_data['image_base64'] is not None
        
        if not has_text and not has_audio and not has_image:
            logger.warning("Nem texto, √°udio ou imagem encontrados nos dados")
            return {
                "error": "Nem texto, √°udio ou imagem encontrados",
                "received_data": data,
                "hint": (
                    "Certifique-se de que h√° 'conversation' para texto, "
                    "'audioMessage' com 'base64' para √°udio, ou "
                    "'imageMessage' com 'base64' para imagem"
                )
            }

        remote_jid = evolution_data['remote_jid']
        push_name = evolution_data['push_name']
        message_type = evolution_data['message_type']

        logger.info(f"   - Tipo de mensagem: {message_type}")
        if has_text:
            logger.info(f"   - Texto: {evolution_data['message']}")
        if has_audio:
            audio_length = len(evolution_data['audio_base64'])
            logger.info(f"   - √Åudio: {audio_length} chars base64")
        if has_image:
            image_length = len(evolution_data['image_base64'])
            logger.info(f"   - Imagem: {image_length} chars base64")
        logger.info(f"   - RemoteJid: {remote_jid}")
        logger.info(f"   - Nome do usu√°rio: {push_name}")

        # Usar session_id baseado no remote_jid para manter hist√≥rico
        session_id = f"elo-{remote_jid}"
        
        # Extrair n√∫mero do WhatsApp do remoteJid para as ferramentas
        whatsapp_number = remote_jid.replace("@s.whatsapp.net", "")
        logger.info(f"üì± N√∫mero extra√≠do para ferramentas: {whatsapp_number}")

        # Enviar para Vanessa com session_id (hist√≥rico autom√°tico)
        logger.info("üéØ Vanessa consultando base de conhecimento e "
                    "respondendo...")
        
        # Criar instru√ß√µes din√¢micas com o n√∫mero espec√≠fico do cliente
        dynamic_instructions = f"""
CONTEXTO ATUAL:
- Cliente: {push_name}
- N√∫mero WhatsApp: {whatsapp_number}

üì¢ IMPORTANTE: A pergunta sobre card√°pio online J√Å FOI ENVIADA!
Continue a conversa a partir da resposta do cliente.
N√ÉO repita: "Oi, √© do restaurante?" - v√° direto ao acompanhamento!

üÜò N√öMERO DE EMERG√äNCIA: 5548996438314
Se houver problemas t√©cnicos ou n√£o conseguir agendar, redirecione!

üö® INSTRU√á√ÉO ESPEC√çFICA PARA AGENDAMENTO:
Se o cliente mencionar "reuni√£o", "marcar", "agendar" ou similares,
CONSULTE sua base de conhecimento 'calend√°rio_agendamento.txt'
SIGA EXATAMENTE o fluxo descrito no documento:
1. PRIMEIRO: Execute shell_tools com ['date', '+%A, %d de %B de %Y'] para 
saber que dia √© HOJE
2. SEGUNDO: Use list_events() para consultar agenda
3. TERCEIRO: Sugira hor√°rios espec√≠ficos FUTUROS baseados na disponibilidade REAL
4. QUARTO: Quando cliente escolher, use create_event() com DATA CORRETA
5. QUINTO: Confirme com link do Google Meet

‚ö†Ô∏è NUNCA invente datas! SEMPRE consulte o sistema para saber que dia √© hoje!
NUNCA pergunte "qual hor√°rio prefere" sem sugerir op√ß√µes espec√≠ficas!

INSTRU√á√ïES DE FERRAMENTAS:
Quando usar send_media_message, use sempre:
- number: {whatsapp_number}
- media_type: 'image'

Para resultados financeiros (R$ 877.000):
- media: 'knowledge/relatorio.jpg'
- caption: 'Aqui est√£o os resultados reais dos nossos clientes'

Para crescimento (300%):
- media: 'knowledge/visualizacao.jpg' 
- caption: 'Visualiza√ß√£o do crescimento dos nossos clientes'

SEMPRE use as ferramentas quando mencionar resultados!
"""
        
        # Processar baseado no tipo de mensagem
        try:
            if message_type == 'image' and has_image:
                logger.info("üñºÔ∏è Processando mensagem de imagem")
                response = vanessa.run(
                    images=[evolution_data['image_base64']], 
                    session_id=session_id
                )
            elif message_type == 'audio' and has_audio:
                logger.info("üìª Processando mensagem de √°udio")
                response = vanessa.run(
                    audio=evolution_data['audio_base64'], 
                    session_id=session_id
                )
            else:
                logger.info("üìù Processando mensagem de texto")
                # Incluir instru√ß√µes din√¢micas na mensagem
                message_with_context = f"{dynamic_instructions}\n\nMENSAGEM DO CLIENTE: {evolution_data['message']}"
                response = vanessa.run(
                    message_with_context, 
                    session_id=session_id
                )
            
            logger.info(f"üîç Resposta do agente - Tipo: {type(response)}")
            if hasattr(response, 'content'):
                logger.info(f"üîç Content: {response.content}")
            if hasattr(response, 'tool_calls') and response.tool_calls:
                logger.info(f"üîß Tool calls detectados: {len(response.tool_calls)}")
                for i, tool_call in enumerate(response.tool_calls):
                    logger.info(f"üîß Tool call {i+1}: {tool_call}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao executar agente: {e}")
            logger.error(f"‚ùå Tipo do erro: {type(e)}")
            import traceback
            logger.error(f"‚ùå Traceback: {traceback.format_exc()}")
            response = None

        # Extrair apenas o conte√∫do da mensagem com verifica√ß√£o de None
        if response is None:
            message = "Erro: Resposta vazia do agente"
        elif hasattr(response, 'content') and response.content:
            message = response.content
        elif hasattr(response, 'content') and response.content is None:
            # Agente pode ter usado ferramentas sem retornar texto
            message = "Perfeito! Vou te enviar os materiais de comprova√ß√£o."
        else:
            # Fallback para outros casos
            message = "Aguarde um momento, estou processando sua solicita√ß√£o."
        
        # Garantir que message nunca seja None
        if message is None:
            message = "Erro: N√£o foi poss√≠vel obter resposta"

        logger.info(f"‚úÖ Vanessa respondeu com sucesso "
                    f"(tamanho: {len(message)} caracteres)")

        return {
            "message": "Resposta enviada via WhatsApp",
        }

    except Exception as e:
        logger.error(f"‚ùå Erro na conversa com Vanessa: {str(e)}")
        return {"error": f"Erro ao processar conversa: {str(e)}"}


@app.get("/status")
async def status():
    """Status do sistema de capta√ß√£o"""
    faq_exists = os.path.exists("faq.txt")

    return {
        "status": "Sistema ativo",
        "agente": "Vanessa - Elo Marketing",
        "funcionalidades": [
            "Capta√ß√£o de leads para restaurantes",
            "Base de conhecimento vetorizada",
            "Busca sem√¢ntica no script de vendas",
            "Tratamento de obje√ß√µes via FAQ",
            "Agendamento com Eduardo",
            "Hist√≥rico de conversas"
        ],
        "knowledge_system": {
            "faq_file": "faq.txt",
            "faq_loaded": faq_exists,
            "chunking_strategy": "paragraph",
            "search_method": "semantic_search"
        },
        "database": "sessions.db (SQLite)"
    }


@app.post("/test-evolution")
async def test_evolution():
    """Testa as ferramentas Evolution API diretamente"""
    try:
        if not evolution_tools:
            return {"error": "Evolution API Tools n√£o configurado"}
        
        # Teste direto das ferramentas
        result = evolution_tools.send_text_message(
            number="5548996438314",
            text="Teste direto das ferramentas Evolution API!"
        )
        
        return {
            "status": "sucesso",
            "result": result,
            "tools_available": dir(evolution_tools)
        }
    except Exception as e:
        return {"error": str(e)}


@app.post("/enviar-lista-restaurantes")
async def enviar_lista_restaurantes(file: UploadFile = File(...)):
    """
    Endpoint para processar lista de restaurantes e enviar primeira mensagem
    Formato esperado do CSV: nome,numero
    """
    try:
        # Verificar se o arquivo √© CSV
        if not file.filename.endswith('.csv'):
            return {"error": "Arquivo deve ser CSV"}
        
        # Ler conte√∫do do arquivo
        content = await file.read()
        content_str = content.decode('utf-8')
        
        # Processar CSV
        csv_reader = csv.reader(content_str.splitlines())
        restaurantes_processados = []
        restaurantes_erro = []
        
        # Mensagem primeira intera√ß√£o
        primeira_mensagem = (
            "Oi! Aqui √© a Vanessa da Elo Marketing. "
            "√â de um restaurante? Voc√™s t√™m card√°pio ou menu online?"
        )
        
        for i, row in enumerate(csv_reader):
            # Pular header se existir
            if i == 0 and ('nome' in row[0].lower() or 'name' in row[0].lower()):
                continue
                
            if len(row) < 2:
                restaurantes_erro.append({
                    "linha": i + 1,
                    "erro": "Formato inv√°lido - necess√°rio nome,numero"
                })
                continue
            
            nome = row[0].strip()
            numero = row[1].strip()
            
            # Limpar n√∫mero (remover caracteres especiais)
            numero_limpo = ''.join(filter(str.isdigit, numero))
            
            if len(numero_limpo) < 10:
                restaurantes_erro.append({
                    "linha": i + 1,
                    "nome": nome,
                    "numero": numero,
                    "erro": "N√∫mero muito curto"
                })
                continue
            
            try:
                # Salvar no banco de dados
                conn = sqlite3.connect("restaurantes.db")
                cursor = conn.cursor()
                
                # Verificar se j√° existe
                cursor.execute(
                    "SELECT id, primeira_mensagem_enviada FROM restaurantes WHERE numero = ?",
                    (numero_limpo,)
                )
                existing = cursor.fetchone()
                
                if existing:
                    if existing[1]:  # J√° enviou mensagem
                        restaurantes_erro.append({
                            "linha": i + 1,
                            "nome": nome,
                            "numero": numero_limpo,
                            "erro": "Mensagem j√° enviada anteriormente"
                        })
                        conn.close()
                        continue
                else:
                    # Inserir novo restaurante
                    cursor.execute(
                        """INSERT INTO restaurantes (nome, numero) 
                           VALUES (?, ?)""",
                        (nome, numero_limpo)
                    )
                
                # Para teste, enviar apenas para o n√∫mero especificado
                numero_envio = "5548996438314"  # N√∫mero de teste
                
                if evolution_tools:
                    try:
                        # Enviar mensagem
                        result = evolution_tools.send_text_message(
                            number=numero_envio,
                            text=f"TESTE - {nome}: {primeira_mensagem}"
                        )
                        
                        # Marcar como enviado no banco
                        cursor.execute(
                            """UPDATE restaurantes 
                               SET primeira_mensagem_enviada = TRUE, data_envio = ?
                               WHERE numero = ?""",
                            (datetime.now(), numero_limpo)
                        )
                        
                        restaurantes_processados.append({
                            "nome": nome,
                            "numero": numero_limpo,
                            "numero_teste": numero_envio,
                            "status": "enviado",
                            "result": str(result)
                        })
                        
                    except Exception as e:
                        restaurantes_erro.append({
                            "linha": i + 1,
                            "nome": nome,
                            "numero": numero_limpo,
                            "erro": f"Erro ao enviar: {str(e)}"
                        })
                else:
                    restaurantes_erro.append({
                        "linha": i + 1,
                        "nome": nome,
                        "numero": numero_limpo,
                        "erro": "Evolution API n√£o configurada"
                    })
                
                conn.commit()
                conn.close()
                
            except sqlite3.IntegrityError:
                restaurantes_erro.append({
                    "linha": i + 1,
                    "nome": nome,
                    "numero": numero_limpo,
                    "erro": "N√∫mero j√° existe no banco"
                })
            except Exception as e:
                restaurantes_erro.append({
                    "linha": i + 1,
                    "nome": nome,
                    "numero": numero,
                    "erro": str(e)
                })
        
        return {
            "status": "processado",
            "total_linhas": i + 1,
            "processados": len(restaurantes_processados),
            "erros": len(restaurantes_erro),
            "restaurantes_processados": restaurantes_processados,
            "restaurantes_erro": restaurantes_erro,
            "observacao": "MODO TESTE: Todas as mensagens foram enviadas para 5548996438314"
        }
        
    except Exception as e:
        logger.error(f"‚ùå Erro ao processar lista de restaurantes: {e}")
        return {"error": f"Erro interno: {str(e)}"}


@app.get("/restaurantes")
async def listar_restaurantes():
    """Lista todos os restaurantes cadastrados"""
    try:
        conn = sqlite3.connect("restaurantes.db")
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT id, nome, numero, primeira_mensagem_enviada, 
                   data_envio, created_at
            FROM restaurantes 
            ORDER BY created_at DESC
        """)
        
        rows = cursor.fetchall()
        conn.close()
        
        restaurantes = []
        for row in rows:
            restaurantes.append({
                "id": row[0],
                "nome": row[1],
                "numero": row[2],
                "primeira_mensagem_enviada": bool(row[3]),
                "data_envio": row[4],
                "created_at": row[5]
            })
        
        return {
            "total": len(restaurantes),
            "restaurantes": restaurantes
        }
        
    except Exception as e:
        return {"error": str(e)}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8082)
