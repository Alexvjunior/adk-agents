import os
import logging
import json
import tempfile
import threading
from datetime import datetime
from typing import Dict
from dotenv import load_dotenv
from fastapi import FastAPI, Request
from agno.agent import Agent
from agno.models.google import Gemini
from agno.storage.agent.sqlite import SqliteAgentStorage
from agno.knowledge.text import TextKnowledgeBase
from agno.tools.knowledge import KnowledgeTools
from agno.tools.googlecalendar import GoogleCalendarTools
from agno.tools.shell import ShellTools
from agno.document.chunking.recursive import RecursiveChunking
from agno.knowledge.agent import AgentKnowledge
from agno.vectordb.chroma import ChromaDb
from agno.document.reader.text_reader import TextReader
from agno.embedder.google import GeminiEmbedder
from pathlib import Path
from evolution_api_tools import EvolutionApiTools

# Carregar vari√°veis de ambiente
load_dotenv()

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI()


# Sistema de Follow-up Autom√°tico
class FollowUpManager:
    """Gerencia follow-ups autom√°ticos ap√≥s per√≠odo de inatividade"""
    
    def __init__(self):
        self.pending_followups: Dict[str, threading.Timer] = {}
        self.last_interaction: Dict[str, datetime] = {}
        self.followup_delay = 20 * 60  # 20 minutos em segundos
        self.scheduled_clients = set()  # Clientes que agendaram reuni√£o
        
    def schedule_followup(self, remote_jid: str, 
                         evolution_tools: EvolutionApiTools):
        """Agenda um follow-up para ser enviado ap√≥s 20 minutos"""
        # N√£o agendar follow-up se cliente j√° agendou reuni√£o
        if remote_jid in self.scheduled_clients:
            logger.info(f"üö´ Follow-up n√£o agendado para {remote_jid} - "
                       f"cliente j√° agendou reuni√£o")
            return
        
        # Cancelar follow-up anterior se existir
        self.cancel_followup(remote_jid)
        
        # Registrar √∫ltima intera√ß√£o
        self.last_interaction[remote_jid] = datetime.now()
        
        # Criar timer para follow-up
        timer = threading.Timer(
            self.followup_delay,
            self._send_followup,
            args=[remote_jid, evolution_tools]
        )
        
        self.pending_followups[remote_jid] = timer
        timer.start()
        
        logger.info(f"‚è∞ Follow-up agendado para {remote_jid} em 20 minutos")
    
    def cancel_followup(self, remote_jid: str):
        """Cancela follow-up pendente (quando usu√°rio responde)"""
        if remote_jid in self.pending_followups:
            self.pending_followups[remote_jid].cancel()
            del self.pending_followups[remote_jid]
            logger.info(f"‚ùå Follow-up cancelado para {remote_jid}")
    
    def stop_followup_permanently(self, remote_jid: str, reason: str = "agendou reuni√£o"):
        """Para follow-up permanentemente (quando cliente agenda reuni√£o)"""
        # Cancelar follow-up pendente
        self.cancel_followup(remote_jid)
        
        # Adicionar √† lista de clientes que agendaram
        self.scheduled_clients.add(remote_jid)
        
        logger.info(f"üõë Follow-up PERMANENTEMENTE DESATIVADO para {remote_jid} - {reason}")
    
    def reactivate_followup(self, remote_jid: str):
        """Reativa follow-up (caso necess√°rio)"""
        if remote_jid in self.scheduled_clients:
            self.scheduled_clients.remove(remote_jid)
            logger.info(f"üîÑ Follow-up reativado para {remote_jid}")
    
    def check_if_appointment_made(self, message_content: str, remote_jid: str):
        """Verifica se mensagem indica agendamento feito com sucesso"""
        # Palavras-chave que indicam agendamento bem-sucedido
        appointment_keywords = [
            "agendado com sucesso",
            "reuni√£o marcada",
            "encontro agendado", 
            "conversa agendada",
            "evento criado",
            "agendamento confirmado",
            "reuni√£o confirmada",
            "evento adicionado ao calend√°rio",
            "nossa reuni√£o est√° marcada"
        ]
        
        message_lower = message_content.lower()
        for keyword in appointment_keywords:
            if keyword in message_lower:
                logger.info(f"üìÖ AGENDAMENTO DETECTADO para {remote_jid}: '{keyword}'")
                return True
        
        return False
    
    def _send_followup(self, remote_jid: str, 
                      evolution_tools: EvolutionApiTools):
        """Envia mensagem de follow-up autom√°tica"""
        # Verificar se cliente n√£o agendou reuni√£o antes de enviar
        if remote_jid in self.scheduled_clients:
            logger.info(f"üö´ Follow-up cancelado - {remote_jid} j√° agendou reuni√£o")
            return
        
        try:
            # Extrair n√∫mero do JID (remover @s.whatsapp.net)
            number = remote_jid.replace("@s.whatsapp.net", "")
            
            # Mensagens de follow-up variadas
            followup_messages = [
                ("Ol√°! Vi que voc√™ estava interessado nos nossos resultados. "
                 "Tem alguma d√∫vida sobre como conseguimos R$ 877.000 para "
                 "nossos clientes?"),
                ("Oi! Ainda est√° por a√≠? Nossos restaurantes parceiros "
                 "aumentaram vendas em 300%. Quer saber como aplicamos "
                 "isso no seu neg√≥cio?"),
                ("Ei! N√£o queria deixar passar a oportunidade. Nosso Eduardo "
                 "pode mostrar exatamente como conseguimos esses resultados "
                 "incr√≠veis para restaurantes."),
                ("Ol√°! Talvez tenha perdido minha mensagem anterior. Temos "
                 "cases reais de restaurantes que sa√≠ram de pouco movimento "
                 "para faturar mais de R$ 877 mil!")
            ]
            
            # Escolher mensagem baseada no hor√°rio (para variar)
            import random
            message = random.choice(followup_messages)
            
            # Enviar follow-up
            result = evolution_tools.send_text_message(
                number=number,
                text=message
            )
            
            logger.info(f"üì§ Follow-up enviado para {number}: {result}")
            
            # Limpar da lista de pendentes
            if remote_jid in self.pending_followups:
                del self.pending_followups[remote_jid]
                
        except Exception as e:
            logger.error(f"‚ùå Erro ao enviar follow-up para {remote_jid}: {e}")


# Inst√¢ncia global do gerenciador de follow-up
followup_manager = FollowUpManager()

# Usar vari√°vel de ambiente para Google API Key
google_api_key = os.getenv("GOOGLE_API_KEY", 
                           "AIzaSyCKTbPQDtAhUI9VWQH26_v2KJW3146Xe20")
os.environ["GOOGLE_API_KEY"] = google_api_key

storage = SqliteAgentStorage(table_name="sessions", db_file="sessions.db")

knowledge_base = TextKnowledgeBase(
    path="knowledge/",
    chunking_strategy=RecursiveChunking(
        chunk_size=1000, overlap=100
    ),
)


agent_knowledge = AgentKnowledge(

    vector_db=ChromaDb(
        collection="elo_marketing_knowledge",
        embedder=GeminiEmbedder(
            id="text-embedding-004",  # Modelo de embedding do Google
            # Usa sua API key existente
            api_key=os.environ.get("GOOGLE_API_KEY")
        ),
        path="knowledge_db",
        persistent_client=True,
    ),
    chunking_strategy=RecursiveChunking(
        chunk_size=1000,
        overlap=100
    ),
    num_documents=5,
)

reader = TextReader(chunk=True)
knowledge_dir = Path("knowledge/")
for file_path in knowledge_dir.iterdir():
    if file_path.is_file() and file_path.suffix == '.txt':  # S√≥ arquivos .txt
        print(f"Processando arquivo: {file_path}")
        documents = reader.read(file_path)
        for doc in documents:
            print(f"Documento adicionado: {doc.name}")
            agent_knowledge.add_document_to_knowledge_base(document=doc)

knowledge = KnowledgeTools(
    knowledge=knowledge_base,
    think=True,
    search=True,
    analyze=True,
    instructions="Use sempre as conversas reais para responder perguntas. Procure por "
                 "respostas espec√≠ficas no knowledge base antes de responder.",
)


def create_google_calendar_tools():
    """Cria GoogleCalendarTools usando vari√°veis de ambiente"""
    try:
        # Criar estrutura de credenciais a partir de vari√°veis de ambiente
        credentials_dict = {
            "installed": {
                "client_id": os.getenv("GOOGLE_CLIENT_ID"),
                "project_id": os.getenv("GOOGLE_PROJECT_ID"),
                "auth_uri": "https://accounts.google.com/o/oauth2/auth",
                "token_uri": "https://oauth2.googleapis.com/token",
                "auth_provider_x509_cert_url": (
                    "https://www.googleapis.com/oauth2/v1/certs"
                ),
                "client_secret": os.getenv("GOOGLE_CLIENT_SECRET"),
                "redirect_uris": [
                    "http://localhost", 
                    "https://agentes-agents.iaz7eb.easypanel.host/"
                ]
            }
        }
        
        # Criar estrutura de token a partir de vari√°veis de ambiente
        token_dict = {
            "refresh_token": os.getenv("GOOGLE_REFRESH_TOKEN"),
            "token_uri": "https://oauth2.googleapis.com/token",
            "client_id": os.getenv("GOOGLE_CLIENT_ID"),
            "client_secret": os.getenv("GOOGLE_CLIENT_SECRET"),
            "scopes": ["https://www.googleapis.com/auth/calendar"],
            "universe_domain": "googleapis.com"
        }
        
        # Criar arquivos tempor√°rios para as credenciais
        with tempfile.NamedTemporaryFile(
            mode='w', suffix='.json', delete=False
        ) as credentials_file:
            json.dump(credentials_dict, credentials_file)
            credentials_path = credentials_file.name
            
        with tempfile.NamedTemporaryFile(
            mode='w', suffix='.json', delete=False
        ) as token_file:
            json.dump(token_dict, token_file)
            token_path = token_file.name
        
        # Criar e retornar GoogleCalendarTools
        return GoogleCalendarTools(
            credentials_path=credentials_path,
            token_path=token_path,
        )
        
    except Exception as e:
        logger.error(f"Erro ao criar GoogleCalendarTools: {e}")
        # Retorna None se houver erro, para o agente funcionar sem calend√°rio
        return None


# Criar ferramentas de calend√°rio usando vari√°veis de ambiente
calendar = create_google_calendar_tools()

# Ferramenta Shell para executar comandos (obter data/hora atual)
shell_tools = ShellTools(base_dir=Path("."))

# Criar ferramentas Evolution API para WhatsApp
try:
    evolution_tools = EvolutionApiTools(
        server_url='https://evolution-api-evolution-api.iaz7eb.easypanel.host',
        api_key='88B69AFEDA22-4836-858D-72852AA04B1F',
        instance='Dudu Numero N√£o Usando'
    )
    logger.info("Evolution API Tools configurado com sucesso")
except Exception as e:
    logger.error(f"Erro ao configurar Evolution API Tools: {e}")
    evolution_tools = None

# Definir ferramentas baseado na disponibilidade do calend√°rio
tools = [shell_tools, knowledge]
if calendar:
    tools.append(calendar)
    logger.info("Google Calendar configurado com sucesso")
else:
    warning_msg = ("Google Calendar n√£o configurado - "
                   "verifique as vari√°veis de ambiente")
    logger.warning(warning_msg)

# Adicionar Evolution API Tools se dispon√≠vel
if evolution_tools:
    # Configurar ferramentas para execu√ß√£o direta
    evolution_tools.external_execution_required_tools = []
    tools.append(evolution_tools)
    logger.info("Evolution API Tools adicionado ao agente")
    # Debug: Log available methods
    logger.info(f"üîß M√©todos dispon√≠veis nas ferramentas: {dir(evolution_tools)}")
    logger.info(f"üîß Fun√ß√µes das ferramentas: {evolution_tools.functions}")
else:
    logger.error("‚ùå Evolution API Tools n√£o est√° dispon√≠vel")


# Criar agente Vanessa - Vendedora da Elo Marketing
vanessa = Agent(
    name="Vanessa",
    role="Vendedora da Elo Marketing especializada em restaurantes",
    model=Gemini(id="gemini-2.5-pro"),
    storage=storage,
    tools=tools,  # Adicionado shell_tools
    knowledge=agent_knowledge,
    add_history_to_messages=True,
    tool_choice="auto",
    instructions=[
        "Voc√™ √© Vanessa, vendedora da Elo Marketing.",
        "",
        "üö® REGRA CR√çTICA - DATA ATUAL:",
        "SEMPRE use shell_tools para consultar a data de hoje ANTES de agendar!",
        "Comando: ['date', '+%A, %d de %B de %Y']",
        "NUNCA invente datas - SEMPRE consulte o sistema!",
        "",
        "üö® REGRA #1 - AGENDAMENTO (OBRIGAT√ìRIO):",
        "Se cliente disser: 'reuni√£o', 'marcar', 'agendar', 'aceito', 'topa'",
        "IMEDIATAMENTE execute em sequ√™ncia:",
        "1. list_events() - OBRIGAT√ìRIO para ver agenda",
        "2. Sugira 2 hor√°rios livres: 'Eduardo tem ter√ßa 14h e quinta 16h'",
        "3. Quando cliente escolher: create_event() - OBRIGAT√ìRIO",
        "",
        "üö® NUNCA sugira hor√°rios sem executar list_events() primeiro!",
        "üö® NUNCA confirme agendamento sem executar create_event()!",
        "",
        "üÜò N√öMERO DE EMERG√äNCIA:",
        "Se houver qualquer problema na conversa ou n√£o conseguir comunicar:",
        "- Ferramentas n√£o funcionam",
        "- Cliente muito confuso ou irritado", 
        "- Problema t√©cnico no sistema",
        "- N√£o consegue agendar ap√≥s 3 tentativas",
        "Redirecione para: 5548996438314 (WhatsApp de suporte)",
        "Diga: 'Para melhor atendimento, entre em contato: 5548996438314'",
        "",
        "üö® INSTRU√á√ïES CR√çTICAS DE AGENDAMENTO - FLUXO OBRIGAT√ìRIO:",
        "",
        "‚ö° GATILHOS PARA USAR FERRAMENTAS (palavras-chave):",
        "Se cliente disser: 'reuni√£o', 'marcar', 'agendar', 'aceito', 'topa', 'sim, quero'",
        "‚Üí IMEDIATAMENTE execute este fluxo OBRIGAT√ìRIO:",
        "",
        "üî• PASSO 1 - CONSULTAR CALEND√ÅRIO (OBRIGAT√ìRIO):",
        "ANTES de sugerir qualquer hor√°rio, SEMPRE EXECUTE:",
        "list_events() ‚Üê Esta ferramenta √© OBRIGAT√ìRIA!",
        "NUNCA sugira hor√°rios sem consultar a agenda primeiro!",
        "",
        "üìÖ PASSO 1.5 - CONSULTAR DATA ATUAL (OBRIGAT√ìRIO):",
        "ANTES de sugerir datas, SEMPRE EXECUTE:",
        "shell_tools com comando: ['date', '+%A, %d de %B de %Y']",
        "NUNCA invente datas - SEMPRE consulte o sistema!",
        "Certifique-se que datas sugeridas s√£o FUTURAS, n√£o passadas!",
        "",
        "üî• PASSO 2 - SUGERIR HOR√ÅRIOS BASEADOS NA AGENDA REAL:",
        "Ap√≥s executar list_events(), responda EXATAMENTE assim:",
        "'Consultei a agenda do Eduardo. Ele tem disponibilidade ter√ßa √†s 14h ou quarta √†s 10h'",
        "OU: 'Eduardo est√° livre quinta de manh√£ √†s 9h ou sexta √†s 15h'", 
        "OU: 'A agenda mostra vagas segunda √†s 11h ou ter√ßa √†s 16h'",
        "SEMPRE ofere√ßa 2 hor√°rios espec√≠ficos diferentes!",
        "",
        "üî• PASSO 3 - COLETAR DADOS QUANDO CLIENTE ESCOLHER:",
        "Cliente escolhe hor√°rio ‚Üí Responda:",
        "'Para finalizar, preciso: nome completo, nome do restaurante e email'",
        "COLETE TODOS os dados antes de criar o evento!",
        "",
        "üî• PASSO 4 - CRIAR EVENTO NO CALEND√ÅRIO (OBRIGAT√ìRIO):",
        "Quando tiver todos os dados, SEMPRE EXECUTE:",
        "create_event(timezone='America/Sao_Paulo', add_google_meet_link=True)",
        "NUNCA confirme agendamento sem executar create_event()!",
        "",
        "üî• PASSO 5 - CONFIRMAR COM LINK DO MEET:",
        "Ap√≥s create_event(), responda:",
        "'Reuni√£o agendada para [data/hora]!'",
        "'Link do Google Meet: [url extra√≠do do evento criado]'",
        "'Eduardo j√° recebeu os detalhes por email'",
        "",
        "‚ùå PROIBI√á√ïES ABSOLUTAS:",
        "- JAMAIS sugira hor√°rios sem executar list_events() primeiro",
        "- JAMAIS confirme agendamento sem executar create_event()",
        "- JAMAIS diga 'Eduardo entrar√° em contato' - VOC√ä agenda!",
        "- JAMAIS pergunte 'qual hor√°rio prefere' sem dar op√ß√µes espec√≠ficas",
        "- JAMAIS finja que agendou sem usar as ferramentas",
        "",
        "‚úÖ EXEMPLO COMPLETO OBRIGAT√ìRIO:",
        "Cliente: 'Aceito agendar'",
        "Voc√™: EXECUTA shell_tools(['date', '+%A, %d de %B de %Y']) para saber que dia √© hoje",
        "Voc√™: EXECUTA list_events() para ver agenda dispon√≠vel",
        "Voc√™: 'Consultei a agenda do Eduardo. Ele tem disponibilidade ter√ßa √†s 14h ou quinta √†s 16h'",
        "Cliente: 'Ter√ßa √†s 14h'", 
        "Voc√™: 'Para finalizar, preciso: nome completo, nome do restaurante e email'",
        "Cliente: 'Jo√£o Silva, Restaurante Sabor, joao@email.com'",
        "Voc√™: EXECUTA create_event() com data FUTURA correta",
        "Voc√™: 'Reuni√£o agendada para ter√ßa √†s 14h! Link do Google Meet: [url]'",
        "",
        "üö® TIMEZONE OBRIGAT√ìRIO:",
        "SEMPRE use timezone='America/Sao_Paulo' em create_event()",
        "SEMPRE use add_google_meet_link=True em create_event()",
        "",
        "üîÑ GERENCIAMENTO DE AGENDAMENTOS:",
        "",
        "üìÖ CANCELAMENTO DE REUNI√ÉO:",
        "Se cliente disser: 'cancelar', 'desmarcar', 'n√£o posso mais'",
        "1. Use list_events() para encontrar a reuni√£o do cliente",
        "2. Use delete_event() para cancelar a reuni√£o",
        "3. Confirme: 'Reuni√£o cancelada com sucesso!'",
        "",
        "‚úèÔ∏è ALTERA√á√ÉO DE HOR√ÅRIO:",
        "Se cliente disser: 'mudar hor√°rio', 'alterar', 'outro dia'",
        "1. Use list_events() para encontrar a reuni√£o atual",
        "2. Use delete_event() para cancelar a reuni√£o antiga",
        "3. Use list_events() novamente para ver disponibilidade",
        "4. Sugira novos hor√°rios livres",
        "5. Use create_event() para novo hor√°rio escolhido",
        "",
        "üö´ PREVEN√á√ÉO DE CONFLITOS - REGRA ABSOLUTA:",
        "NUNCA agende duas reuni√µes no mesmo hor√°rio!",
        "SEMPRE verifique list_events() antes de create_event()",
        "Se hor√°rio j√° ocupado, sugira alternativas:",
        "'Esse hor√°rio j√° est√° ocupado. Posso ter√ßa √†s 15h ou quinta √†s 14h'",
        "",
        "üîç VERIFICA√á√ÉO OBRIGAT√ìRIA ANTES DE AGENDAR:",
        "1. EXECUTE list_events() primeiro",
        "2. ANALISE os hor√°rios ocupados",
        "3. SUGIRA apenas hor√°rios LIVRES",
        "4. CONFIRME que n√£o h√° conflito antes de create_event()",
        "",
        "PITCH ATACANTE - USE IMEDIATAMENTE QUANDO APROPRIADO:",
        "Eu trabalho ajudando restaurantes a aumentarem suas vendas atrav√©s "
        "do marketing digital. Conseguimos faturar mais de R$ 877.000 para "
        "nossos clientes com investimento de apenas R$ 7 mil. Crescimento "
        "de mais de 300% nas vendas.",
        "",
        "üì¢ ABERTURA PADR√ÉO (j√° foi enviada por outro sistema):",
        "A pergunta 'Oi, √© do Restaurante? Voc√™s t√™m card√°pio ou menu online?' "
        "J√Å FOI ENVIADA por outro sistema.",
        "CONTINUE a conversa a partir da resposta do cliente a essa pergunta.",
        "N√ÉO repita a abertura - v√° direto ao acompanhamento.",
        "",
        "üö® PROIBIDO FINGIR QUE AGENDOU:",
        "JAMAIS diga 'reuni√£o foi agendada' sem executar create_event!",
        "JAMAIS diga 'aguarde contato do Eduardo' - VOC√ä faz o agendamento!",
        "Se cliente pedir reuni√£o: SEMPRE sugira hor√°rios espec√≠ficos primeiro!",
        "",
        "‚úÖ FLUXO CORRETO OBRIGAT√ìRIO:",
        "1. Cliente: 'quero reuni√£o' ‚Üí Voc√™: EXECUTE list_events()",
        "2. Baseado na agenda ‚Üí Sugira: 'Posso hoje √†s 14h ou amanh√£ √†s 10h?'",
        "3. Cliente escolhe ‚Üí EXECUTE create_event() com o hor√°rio escolhido",
        "4. Confirme: 'Agendado! Eduardo te liga [dia] √†s [hora]!'",
        "",
        "üéØ HOR√ÅRIOS PADR√ÉO PARA SUGERIR:",
        "Segunda a Sexta: 9h, 10h, 14h, 15h, 16h",
        "SEMPRE ofere√ßa pelo menos 2 op√ß√µes diferentes",
        "Exemplo: 'Tenho segunda √†s 14h ou ter√ßa √†s 10h. Qual prefere?'",
        "",
        "üöÄ REGRAS DE FECHAMENTO:",
        "1. SEMPRE ofere√ßa 2-3 hor√°rios espec√≠ficos quando h√° interesse",
        "2. Use ferramentas de calend√°rio para agendar NA HORA",
        "3. Confirme dados: nome, telefone, nome do restaurante",
        "4. Finalize com: 'Agendado! Eduardo te liga na data marcada!'",
        "",
        "üì± FERRAMENTAS DE WHATSAPP DISPON√çVEIS:",
        "- Use send_text_message para enviar mensagens de texto via WhatsApp",
        "- Use send_media_message para enviar imagens quando mencionar resultados",
        "- Use check_whatsapp_number para verificar se um n√∫mero est√° no WhatsApp",
        "- Formato de n√∫mero: 5548999999999 (c√≥digo pa√≠s + DDD + n√∫mero)",
        "",
        "üî• REGRA FINAL OBRIGAT√ìRIA:",
        "Para CADA resposta que voc√™ gerar, EXECUTE send_text_message!",
        "Nunca apenas retorne texto - SEMPRE envie via send_text_message!",
        "Formato: send_text_message(number='554896438314', text='sua_resposta_aqui')",
        "",
        "üö® AGENDAMENTO - REGRA ABSOLUTA:",
        "Quando cliente pedir reuni√£o, RESPONDA EXATAMENTE assim:",
        "'√ìtimo! Posso agendar segunda √†s 14h ou ter√ßa √†s 10h. Qual prefere?'",
        "NUNCA diga que 'agendou' sem o cliente escolher hor√°rio primeiro!",
        "NUNCA mencione 'Eduardo entrar√° em contato' - sugira hor√°rios espec√≠ficos!",
        "",
        "üìù SCRIPT LITERAL - SIGA EXATAMENTE:",
        "Se mensagem cont√©m: 'reuni√£o' ou 'marcar' ou 'agendar'",
        "RESPONDA SEMPRE: 'Perfeito! Que tal amanh√£ √†s 14h ou quinta √†s 16h? Qual hor√°rio fica melhor?'",
        "N√ÉO pe√ßa dados pessoais. N√ÉO diga que precisa confirmar. SUGIRA HOR√ÅRIOS!"
    ],
    markdown=True,
    show_tool_calls=True,
)


def extract_evolution_data(data):
    """Extrai dados da Evolution API"""
    try:
        # Estrutura t√≠pica da Evolution API
        if isinstance(data, dict):
            # Tentar diferentes estruturas poss√≠veis
            message = None
            audio_base64 = None
            image_base64 = None
            message_type = 'text'  # Padr√£o: texto
            remote_jid = None
            push_name = None
            instance = None

            # NOVO FORMATO 2025: Verificar se √© o novo formato com camada 'data'
            if 'data' in data and isinstance(data['data'], dict):
                payload_data = data['data']
                logger.info("üì¶ Novo formato Evolution API 2025 detectado")
                
                # Extrair mensagem do novo formato
                if 'message' in payload_data and isinstance(payload_data['message'], dict):
                    if 'conversation' in payload_data['message']:
                        message = payload_data['message']['conversation']
                        message_type = 'text'
                    elif 'imageMessage' in payload_data['message'] and 'base64' in payload_data['message']:
                        image_base64 = payload_data['message']['base64']
                        message_type = 'image'
                    elif 'audioMessage' in payload_data['message'] and 'base64' in payload_data['message']:
                        audio_base64 = payload_data['message']['base64']
                        message_type = 'audio'
                
                # Extrair informa√ß√µes do remetente do novo formato
                if 'key' in payload_data and isinstance(payload_data['key'], dict):
                    remote_jid = payload_data['key'].get('remoteJid', 'unknown')
                
                if 'pushName' in payload_data:
                    push_name = payload_data['pushName']
                
                # Instance do payload principal
                if 'instance' in data:
                    instance = data['instance']

            # FORMATO ANTIGO: Verificar se √© o formato com 'query' e 'inputs'
            elif 'query' in data and 'inputs' in data:
                message = data['query']
                message_type = 'text'
                # Extrair informa√ß√µes de inputs
                inputs = data['inputs']
                if isinstance(inputs, dict):
                    remote_jid = inputs.get('remoteJid', 'unknown')
                    push_name = inputs.get('pushName', 'Cliente')
                    instance = inputs.get('instanceName', 'default')
                logger.info("üì¶ Formato antigo Evolution API detectado")

            # Verificar se √© mensagem de imagem (formato antigo)
            elif ('message' in data and isinstance(data['message'], dict) and
                    'imageMessage' in data['message'] and 
                    'base64' in data['message']):
                image_base64 = data['message']['base64']
                message_type = 'image'
                logger.info("üñºÔ∏è Mensagem de imagem detectada")

            # Verificar se √© mensagem de √°udio (formato antigo)
            elif ('message' in data and isinstance(data['message'], dict) and
                    'audioMessage' in data['message'] and 
                    'base64' in data['message']):
                audio_base64 = data['message']['base64']
                message_type = 'audio'
                logger.info("üìª Mensagem de √°udio detectada")

            # Op√ß√£o 1: data.message.conversation (texto) - formato antigo
            elif 'message' in data and isinstance(data['message'], dict):
                if 'conversation' in data['message']:
                    message = data['message']['conversation']
                elif 'text' in data['message']:
                    message = data['message']['text']

            # Op√ß√£o 2: data.text ou data.message direto - formato antigo
            elif 'text' in data:
                message = data['text']
            elif 'message' in data and isinstance(data['message'], str):
                message = data['message']
            elif 'question' in data:  # Para testes diretos
                message = data['question']

            # Extrair informa√ß√µes do remetente (formato antigo)
            if not remote_jid:  # S√≥ se n√£o foi definido no novo formato
                if 'key' in data and isinstance(data['key'], dict):
                    remote_jid = data['key'].get('remoteJid', 'unknown')
                elif 'from' in data:
                    remote_jid = data['from']
                elif 'user' in data:  # Novo formato pode ter 'user'
                    remote_jid = data['user']

            if not push_name:  # S√≥ se n√£o foi definido no novo formato
                if 'pushName' in data:
                    push_name = data['pushName']
                elif 'sender_name' in data:
                    push_name = data['sender_name']

            # Capturar instance ou instanceId
            if not instance:  # S√≥ se n√£o foi definido no novo formato
                if 'instanceId' in data:
                    instance = data['instanceId']
                elif 'instance' in data:
                    instance = data['instance']

            return {
                'message': message,
                'audio_base64': audio_base64,
                'image_base64': image_base64,
                'message_type': message_type,
                'remote_jid': remote_jid or 'unknown',
                'push_name': push_name or 'Cliente',
                'instance': instance or 'default'
            }

    except Exception as e:
        logger.error(f"Erro ao extrair dados da Evolution: {e}")

    return None


@app.get("/")
async def root():
    return {
        "message": "Vanessa - Vendedora Elo Marketing | Especialista em "
                   "Restaurantes",
        "description": (
            "Assistente de vendas especializada em marketing digital para "
            "restaurantes. Ajuda a captar leads qualificados e marcar "
            "reuni√µes com resultados comprovados: crescimento de 300% e "
            "faturamento de R$ 862.000 em um m√™s."
        ),
        "endpoints": {
            "/ask": "Conversa com Vanessa para capta√ß√£o de leads",
            "/status": "Status do sistema de capta√ß√£o"
        },
        "example_curl": (
            "curl -X POST http://127.0.0.1:8080/ask "
            "-H 'Content-Type: application/json' "
            "-d '{\"question\": \"Oi, √© do restaurante?\"}'"
        ),
        "evolution_api": "Compat√≠vel com webhooks da Evolution API",
        "sessions": "Hist√≥rico de conversas por cliente com SQLite",
        "objetivo": "Capta√ß√£o de leads e agendamento de reuni√µes com Eduardo",
        "script_source": "faq.txt - Base de conhecimento vetorizada com Agno",
        "knowledge_system": ("Sistema de conhecimento vetorizado para busca "
                             "sem√¢ntica no script de vendas")
    }


@app.post("/ask")
async def ask_vanessa(request: Request):
    """Conversa com Vanessa - Vendedora da Elo Marketing"""
    try:
        # Log completo do que estamos recebendo
        body = await request.body()
        logger.info("üì• DADOS RAW RECEBIDOS (Evolution API):")
        logger.info(f"   - Body raw: {body}")
        content_type = request.headers.get('content-type')
        logger.info(f"   - Content-Type: {content_type}")

        try:
            data = await request.json()
            logger.info(f"   - JSON parsed: {data}")
        except Exception as json_error:
            logger.error(f"   - Erro ao fazer parse JSON: {json_error}")
            return {
                "error": "Dados recebidos n√£o s√£o JSON v√°lido",
                "raw_data": body.decode()
            }

        # Extrair dados espec√≠ficos da Evolution API
        evolution_data = extract_evolution_data(data)

        if not evolution_data:
            logger.warning("Dados n√£o conseguiram ser extra√≠dos da Evolution")
            return {
                "error": "Dados n√£o conseguiram ser extra√≠dos",
                "received_data": data,
            }

        # Verificar se temos conte√∫do (texto, √°udio ou imagem)
        has_text = evolution_data['message'] is not None
        has_audio = evolution_data['audio_base64'] is not None
        has_image = evolution_data['image_base64'] is not None
        
        if not has_text and not has_audio and not has_image:
            logger.warning("Nem texto, √°udio ou imagem encontrados nos dados")
            return {
                "error": "Nem texto, √°udio ou imagem encontrados",
                "received_data": data,
                "hint": (
                    "Certifique-se de que h√° 'conversation' para texto, "
                    "'audioMessage' com 'base64' para √°udio, ou "
                    "'imageMessage' com 'base64' para imagem"
                )
            }

        remote_jid = evolution_data['remote_jid']
        push_name = evolution_data['push_name']
        message_type = evolution_data['message_type']

        logger.info(f"   - Tipo de mensagem: {message_type}")
        if has_text:
            logger.info(f"   - Texto: {evolution_data['message']}")
        if has_audio:
            audio_length = len(evolution_data['audio_base64'])
            logger.info(f"   - √Åudio: {audio_length} chars base64")
        if has_image:
            image_length = len(evolution_data['image_base64'])
            logger.info(f"   - Imagem: {image_length} chars base64")
        logger.info(f"   - RemoteJid: {remote_jid}")
        logger.info(f"   - Nome do usu√°rio: {push_name}")

        # Usar session_id baseado no remote_jid para manter hist√≥rico
        session_id = f"elo-{remote_jid}"
        
        # Extrair n√∫mero do WhatsApp do remoteJid para as ferramentas
        whatsapp_number = remote_jid.replace("@s.whatsapp.net", "")
        logger.info(f"üì± N√∫mero extra√≠do para ferramentas: {whatsapp_number}")

        # Enviar para Vanessa com session_id (hist√≥rico autom√°tico)
        logger.info("üéØ Vanessa consultando base de conhecimento e "
                    "respondendo...")
        
        # Criar instru√ß√µes din√¢micas com o n√∫mero espec√≠fico do cliente
        dynamic_instructions = f"""
CONTEXTO ATUAL:
- Cliente: {push_name}
- N√∫mero WhatsApp: {whatsapp_number}

üì¢ IMPORTANTE: A pergunta sobre card√°pio online J√Å FOI ENVIADA!
Continue a conversa a partir da resposta do cliente.
N√ÉO repita: "Oi, √© do restaurante?" - v√° direto ao acompanhamento!

üÜò N√öMERO DE EMERG√äNCIA: 5548996438314
Se houver problemas t√©cnicos ou n√£o conseguir agendar, redirecione!

üö® INSTRU√á√ÉO ESPEC√çFICA PARA AGENDAMENTO:
Se o cliente mencionar "reuni√£o", "marcar", "agendar" ou similares,
CONSULTE sua base de conhecimento 'calend√°rio_agendamento.txt'
SIGA EXATAMENTE o fluxo descrito no documento:
1. PRIMEIRO: Execute shell_tools com ['date', '+%A, %d de %B de %Y'] para saber que dia √© HOJE
2. SEGUNDO: Use list_events() para consultar agenda
3. TERCEIRO: Sugira hor√°rios espec√≠ficos FUTUROS baseados na disponibilidade REAL
4. QUARTO: Quando cliente escolher, use create_event() com DATA CORRETA
5. QUINTO: Confirme com link do Google Meet

‚ö†Ô∏è NUNCA invente datas! SEMPRE consulte o sistema para saber que dia √© hoje!
NUNCA pergunte "qual hor√°rio prefere" sem sugerir op√ß√µes espec√≠ficas!

INSTRU√á√ïES DE FERRAMENTAS:
Quando usar send_media_message, use sempre:
- number: {whatsapp_number}
- media_type: 'image'

Para resultados financeiros (R$ 877.000):
- media: 'knowledge/relatorio.jpg'
- caption: 'Aqui est√£o os resultados reais dos nossos clientes'

Para crescimento (300%):
- media: 'knowledge/visualizacao.jpg' 
- caption: 'Visualiza√ß√£o do crescimento dos nossos clientes'

SEMPRE use as ferramentas quando mencionar resultados!
"""
        
        # Processar baseado no tipo de mensagem
        try:
            if message_type == 'image' and has_image:
                logger.info("üñºÔ∏è Processando mensagem de imagem")
                response = vanessa.run(
                    images=[evolution_data['image_base64']], 
                    session_id=session_id
                )
            elif message_type == 'audio' and has_audio:
                logger.info("üìª Processando mensagem de √°udio")
                response = vanessa.run(
                    audio=evolution_data['audio_base64'], 
                    session_id=session_id
                )
            else:
                logger.info("üìù Processando mensagem de texto")
                # Incluir instru√ß√µes din√¢micas na mensagem
                message_with_context = f"{dynamic_instructions}\n\nMENSAGEM DO CLIENTE: {evolution_data['message']}"
                response = vanessa.run(
                    message_with_context, 
                    session_id=session_id
                )
            
            logger.info(f"üîç Resposta do agente - Tipo: {type(response)}")
            if hasattr(response, 'content'):
                logger.info(f"üîç Content: {response.content}")
            if hasattr(response, 'tool_calls') and response.tool_calls:
                logger.info(f"üîß Tool calls detectados: {len(response.tool_calls)}")
                for i, tool_call in enumerate(response.tool_calls):
                    logger.info(f"üîß Tool call {i+1}: {tool_call}")
            
        except Exception as e:
            logger.error(f"‚ùå Erro ao executar agente: {e}")
            logger.error(f"‚ùå Tipo do erro: {type(e)}")
            import traceback
            logger.error(f"‚ùå Traceback: {traceback.format_exc()}")
            response = None

        # Extrair apenas o conte√∫do da mensagem com verifica√ß√£o de None
        if response is None:
            message = "Erro: Resposta vazia do agente"
        elif hasattr(response, 'content') and response.content:
            message = response.content
        elif hasattr(response, 'content') and response.content is None:
            # Agente pode ter usado ferramentas sem retornar texto
            message = "Perfeito! Vou te enviar os materiais de comprova√ß√£o."
        else:
            # Fallback para outros casos
            message = "Aguarde um momento, estou processando sua solicita√ß√£o."
        
        # Garantir que message nunca seja None
        if message is None:
            message = "Erro: N√£o foi poss√≠vel obter resposta"

        logger.info(f"‚úÖ Vanessa respondeu com sucesso "
                    f"(tamanho: {len(message)} caracteres)")

        # SISTEMA DE FOLLOW-UP AUTOM√ÅTICO
        # Verificar se agendamento foi feito
        if followup_manager.check_if_appointment_made(message, remote_jid):
            # Parar follow-up permanentemente se agendamento foi feito
            followup_manager.stop_followup_permanently(remote_jid)
            
            # Enviar mensagem de confirma√ß√£o do agendamento
            if evolution_tools:
                try:
                    number = remote_jid.replace("@s.whatsapp.net", "")
                    confirmation_msg = ("‚úÖ Perfeito! Sua reuni√£o foi agendada. "
                                       "Eduardo entrar√° em contato no hor√°rio marcado. "
                                       "Obrigada por escolher a Elo Marketing!")
                    
                    evolution_tools.send_text_message(
                        number=number,
                        text=confirmation_msg
                    )
                    logger.info(f"üìÖ Confirma√ß√£o de agendamento enviada para {number}")
                except Exception as e:
                    logger.error(f"‚ùå Erro ao enviar confirma√ß√£o: {e}")
        else:
            # Cancelar follow-up anterior (usu√°rio respondeu)
            followup_manager.cancel_followup(remote_jid)
            
            # Agendar novo follow-up se evolution_tools estiver dispon√≠vel
            if evolution_tools:
                followup_manager.schedule_followup(remote_jid, evolution_tools)
                logger.info(f"‚è∞ Follow-up autom√°tico agendado para {remote_jid}")

        return {
            "message": "Resposta enviada via WhatsApp",
        }

    except Exception as e:
        logger.error(f"‚ùå Erro na conversa com Vanessa: {str(e)}")
        return {"error": f"Erro ao processar conversa: {str(e)}"}


@app.get("/status")
async def status():
    """Status do sistema de capta√ß√£o"""
    faq_exists = os.path.exists("faq.txt")

    return {
        "status": "Sistema ativo",
        "agente": "Vanessa - Elo Marketing",
        "funcionalidades": [
            "Capta√ß√£o de leads para restaurantes",
            "Base de conhecimento vetorizada",
            "Busca sem√¢ntica no script de vendas",
            "Tratamento de obje√ß√µes via FAQ",
            "Agendamento com Eduardo",
            "Hist√≥rico de conversas"
        ],
        "knowledge_system": {
            "faq_file": "faq.txt",
            "faq_loaded": faq_exists,
            "chunking_strategy": "paragraph",
            "search_method": "semantic_search"
        },
        "database": "sessions.db (SQLite)"
    }


@app.post("/test-evolution")
async def test_evolution():
    """Testa as ferramentas Evolution API diretamente"""
    try:
        if not evolution_tools:
            return {"error": "Evolution API Tools n√£o configurado"}
        
        # Teste direto das ferramentas
        result = evolution_tools.send_text_message(
            number="5548996438314",
            text="Teste direto das ferramentas Evolution API!"
        )
        
        return {
            "status": "sucesso",
            "result": result,
            "tools_available": dir(evolution_tools)
        }
    except Exception as e:
        return {"error": str(e)}


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8082)
